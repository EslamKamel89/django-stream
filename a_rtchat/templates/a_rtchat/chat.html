<!--prettier-ignore-->
{% extends 'layouts/blank.html' %}

{% block title %} Chat {% endblock %}
{% block content %}
<wrapper class="block max-w-4xl mx-auto px-4" x-data="chat()" x-init="init()">
  <div
    id="chat_window"
    class="flex flex-col bg-white rounded-2xl border border-neutral shadow-lg overflow-hidden"
  >
    <div
      class="flex items-center justify-center gap-2 bg-neutral-100 text-primary font-semibold p-3 top-0 z-10 shrink-0"
    >
      <i class="bi bi-circle-fill text-green-500" x-show="onlineCount "></i>
      <i class="bi bi-circle-fill text-gray-500" x-show="!onlineCount"></i>
      <span id="online-count" x-text="onlineCount"></span> online
    </div>

    <div id="chat_container" class="overflow-y-auto flex-1 bg-neutral-50">
      <ul id="chat_messages" class="flex flex-col gap-2 p-4">
        <!--prettier-ignore-->
        {{ serialized_messages|json_script:'initial-messages' }}
        <template x-for="message in messages" :key="message.id">
          {% include 'a_rtchat/partials/chat_bubble.html'%}
        </template>
      </ul>
    </div>
    <div class="shrink-0 bg-white border-t border-neutral-200 p-4">
      {% include 'a_rtchat/partials/chat_form.html' %}
    </div>
  </div>
</wrapper>
{% endblock %} {% block js %}
<script>
  function chat() {
    return {
      socket: null,
      messages: [],
      body: "",
      error: null,
      sending: false,
      onlineCount: 0,
      init() {
        this.initializeMessages();
        this.connect();
        this.scrollToBottom();
      },
      connect() {
        const protocol = window.location.protocol === "https" ? "wss" : "ws";
        const url = `${protocol}://${window.location.host}/ws/chatroom/django`;
        const socket = new WebSocket(url);
        this.socket = socket;
        socket.onopen = (event) => {
          console.log("onopen", event);
        };
        socket.onclose = (event) => {
          console.log("onclose", event);
        };
        socket.onerror = (error) => {
          console.log("websocket error", error);
        };
        socket.onmessage = (event) => {
          const data = JSON.parse(event.data);
          console.log("onmessage", data);
          if (data.event === "message") {
            this.messageEvent(data);
          }
          if (data.event === "online_count") {
            this.onLineCountEvent(data);
          }
        };
      },
      messageEvent(data) {
        if (data.ok) {
          if (this.messages.findIndex((m) => m.id === data.message.id) === -1) {
            this.messages.push(data.message);
            this.scrollToBottom();
          }
        } else {
          this.error = data?.errors?.body[0];
        }
      },
      onLineCountEvent(data) {
        if (data.ok) {
          this.onlineCount = data.online_count;
        }
      },
      sendMessage() {
        // if (!this.body.trim()) return;
        this.socket.send(JSON.stringify({ body: this.body }));
        this.body = "";
      },
      initializeMessages() {
        const raw = document.getElementById("initial-messages");
        if (raw) {
          this.messages = JSON.parse(raw.textContent);
        }
      },
      async sendMessageHttp() {
        this.error = null;
        this.sending = true;
        try {
          const response = await api.post("{% url 'chat' %}", {
            body: this.body,
          });
          if (response.data.ok) this.messages.push(response.data.message);
          this.body = "";
          this.scrollToBottom();
        } catch (error) {
          if (error?.response?.data?.errors?.body) {
            this.error = error.response.data.errors.body[0];
          }
        } finally {
          this.sending = false;
        }
      },
      scrollToBottom() {
        this.$nextTick(() => {
          const el = document.getElementById("chat_container");
          el.scrollTop = el.scrollHeight;
        });
      },
    };
  }
</script>
{% endblock %}
